---
title: "Workflow and Tooling"
author: ""
format: 
  revealjs:
    theme: simple
    transition: slide
    incremental: true
    slide-number: true
    width: 1280
    height: 720
    fig-cap-location: margin
---
```{r echo = FALSE}
library(reticulate)
use_condaenv("data", required = TRUE)

```

## Overview

- Why did you hire me???
- Why do we _all_ work here?
- Imagine a Bayesian Utopia
- New tools

## Why did you hire me???

- Please tell me.
- I've done a lot of Bayesian meta analysis of RCTs, and I'm good at R.

## Why do we all work here?

Content for the second slide

## Imagine a Bayesian Utopia

- Comprehensive Knowledge Integration: Systematic pre-registration, transparent search protocols, and inclusion of unpublished data to minimize publication bias, with rigorous documentation of all methodological decisions from paper selection through data extraction.
- Sophisticated Measurement Harmonization: Latent variable modeling to reconcile diverse outcome measures across studies, with explicit modeling of measurement error, reliability coefficients, and detection bias to produce more accurate effect estimates.
- Robust Bayesian Hierarchical Modeling: Fully Bayesian estimation with informative priors, multi-level structures capturing dependencies between studies, and explicit modeling of contextual variables and implementation features that drive heterogeneity.
- Reproducibility Infrastructure: Open data repositories, containerized computational environments, complete code sharing with documentation, and interactive dashboards allowing non-technical folks to explore analytical decisions and sensitivity to alternative specifications.
- Decision-Oriented Communication: Translation of statistical findings into practical significance through posterior predictive distributions, decision-theoretic frameworks for policy recommendations, and direct involvement of stakeholders in interpretation and implementation planning.

## It all starts with data quality, and data quality starts with workflow

- Does our code actually do what we say it does? How do we know?
- Can other people find/run/understand/edit/improve it?
- Are our processes confusing and painful such that we call burn out?

## New Tools

- These tools are widely used, so we do our RAs and undergrads a service by having them adopt them -- they will serve them well in any data analysis context, and also are nice resume lines. 
- They 


## 
<br>

<img src="pics/rlang.jpg" width="200" alt="R language logo">

- Open source
- Functions!!!
- Designed specifically for statistical analysis and data science


## 
<img src="pics/git.png" width="200" alt="Git logo">
<br>

- 'Track Changes' on steroids
- The most widely-used version control tool for data analysis
- Free and open-source


## 
<img src="pics/github.png" width="200" alt="GitHub logo">
<br>

- Website where your Git folders live.
- Let's your whole team make changes to the codebase in a transparent and organized way.
- Free and open-source.


## 
<img src="pics/renv.png" width="200" alt="Renv logo">
<br>

- Project-specific package dependency management
- Reproducible environments across machines
- Isolates project dependencies from system libraries


## 
<img src="pics/targets.svg" width="200" alt="Targets logo">
<br>

- Pipeline toolkit for reproducible data science workflows
- Automatically detects which steps need to be rerun.
- Free and open-source.


## 
<img src="pics/styler.png" width="200" alt="Styler logo">
<br>

- Automatically standardizes/reformats all the code in the entire project without changing any of its functionality.
- Lets you choose whatever formatting rules you want.
- Free and open-source.


## 
<img src="pics/lintr.png" width="200" alt="Lintr logo">
<br>

- Automatically checks your code for common bugs, then yells at you if it finds any.
- Can set it up to run automatically any time anybody tries to make changes to the code, preventing errors.
- Free and open-source.


## 
<img src="pics/testthat.png" width="200" alt="Testthat logo">
<br>

- Lets you set up tests to see if your code actually does what you think.
- Provides a basis for test-driven development.
- Free and open-source.

## High-level workflow

- RA Technical Onboarding
- Assigning Tasks
- Writing New Code
- Integrating That New Code

## Technical Onboarding
```{dot}
//| fig-width: 4
//| fig-height: 7
digraph Contributor_Setup {
  // Graph attributes
  rankdir=TB;  // Top to bottom layout
  fontname="Arial";
  fontsize=16;
  label="";
  labelloc="t";
  node [shape=box, style="rounded,filled", fontname="Arial", fontsize=11, margin="0.1,0.1", width=1.2, height=0.4];
  edge [fontname="Arial", fontsize=10, penwidth=1.0];
  
  // Nodes with colors (removed the specified steps)
  github_account [label="Create GitHub account\n(if needed)", fillcolor="#f0f4f8", style="rounded,filled"];
  github_auth [label="Set up GitHub authentication\n(SSH keys or token)", fillcolor="#f0f4f8", style="rounded,filled"];
  fork_repo [label="Fork the main repository\nto your GitHub account", fillcolor="#f0f4f8", style="rounded,filled"];
  clone_fork [label="Clone your fork\nto local machine", fillcolor="#e6e0f3", style="rounded,filled"];
  
  // Edges (updated to connect the remaining nodes)
  github_account -> github_auth;
  github_auth -> fork_repo;
  fork_repo -> clone_fork;
}
```

## Assigning Tasks

```{dot}
//| fig-width: 4
//| fig-height: 7
digraph Issue_Workflow {
  // Graph attributes
  rankdir=TB;  // Top to bottom layout
  fontname="Arial";
  fontsize=16;
  label="";
  labelloc="t";
  node [shape=box, style="rounded,filled", fontname="Arial", fontsize=11, margin="0.1,0.1", width=1.2, height=0.4];
  edge [fontname="Arial", fontsize=10, penwidth=1.0];
  
  // Nodes with colors (consolidated and removed sync_fork)
  identify [label="RA identifies task\nthat needs to be done", fillcolor="#e0eef3", style="rounded,filled"];
  create_issue [label="Create GitHub Issue\nwith informative labels\n(Survey ID, 'missing data', etc)", fillcolor="#f0f4f8", style="rounded,filled"];
  assign_issue [label="Assign issue to contributor\n(or self-assign)", fillcolor="#f0f4f8", style="rounded,filled"];
  branch [label="Create feature branch\nnamed after issue number", fillcolor="#e6e0f3", style="rounded,filled"];
  
  // Edges
  identify -> create_issue;
  create_issue -> assign_issue;
  assign_issue -> branch;
}
```

## Writing New Code

```{dot}
//| fig-width: 4
//| fig-height: 7
digraph Development_Workflow {
  // Graph attributes
  rankdir=TB;  // Top to bottom layout
  fontname="Arial";
  fontsize=16;
  label="";
  labelloc="t";
  node [shape=box, style="rounded,filled", fontname="Arial", fontsize=11, margin="0.1,0.1", width=1.2, height=0.4];
  edge [fontname="Arial", fontsize=10, penwidth=1.0];
  
  // Nodes with colors (streamlined)
  renv_restore [label="renv::restore()\nSet up project environment", fillcolor="#e0f3e0", style="rounded,filled"];
  tar_make_initial [label="targets::tar_make()\nVerify pipeline works\nbefore changes", fillcolor="#e0f3e0", style="rounded,filled"];
  test_dir_initial [label="testthat::test_dir()\nConfirm all tests\npass initially", fillcolor="#f3e0e0", style="rounded,filled"];
  write_tests [label="Write new unit tests for\nthe required functionality", fillcolor="#f3e0e0", style="rounded,filled"];
  implement [label="Implement code changes\nto address the issue", fillcolor="#e0f3e0", style="rounded,filled"];
  test_driven [label="Iterate between coding\nand testing", fillcolor="#f3e0e0", style="rounded,filled"];
  
  // Edges
  renv_restore -> tar_make_initial;
  tar_make_initial -> test_dir_initial;
  test_dir_initial -> write_tests;
  write_tests -> implement;
  implement -> test_driven;
  test_driven -> implement [label="Refine", constraint=false];
}
```

## Integrating That New Code

```{dot}
//| fig-width: 4
//| fig-height: 7
digraph Finalization_Workflow {
  // Graph attributes
  rankdir=TB;  // Top to bottom layout
  fontname="Arial";
  fontsize=16;
  label="";
  labelloc="t";
  node [shape=box, style="rounded,filled", fontname="Arial", fontsize=11, margin="0.1,0.1", width=1.2, height=0.4];
  edge [fontname="Arial", fontsize=10, penwidth=1.0];
  
  // Nodes with colors (removed test_dir and tar_make)
  styling [label="style_dir()\nFormat code consistently", fillcolor="#f8f4e0", style="rounded,filled"];
  linting [label="lint_dir()\nIdentify any code issues", fillcolor="#f8f4e0", style="rounded,filled"];
  commit [label="Commit changes with\nmeaningful message", fillcolor="#e6e0f3", style="rounded,filled"];
  push [label="Push branch to fork", fillcolor="#e6e0f3", style="rounded,filled"];
  pr [label="Open Pull Request\nreferencing the issue", fillcolor="#f0f4f8", style="rounded,filled"];
  review [label="Code Review Process", fillcolor="#f0f4f8", style="rounded,filled"];
  merge [label="PR approved and merged", fillcolor="#f0f4f8", style="rounded,filled"];
  back_to_prev [label="Back to previous slide", fillcolor="#ffffff", style="rounded,filled,dashed"];
  
  // Edges
  styling -> linting;
  linting -> commit;
  commit -> push;
  push -> pr;
  pr -> review;
  review -> back_to_prev [label="Changes\nrequested", style="dashed"];
  review -> merge [label="Approved"];
  
  // Position the "back to prev" node above
  {rank=min; back_to_prev}
}
```

## Peoples' thoughts from yesterday:

- Opportunities for RAs to learn.
- Notion seems like a good tool for documenting questions, but GitHub issues are better because they map specific tasks to specific coders. 
- Romil: we need more input from PIs during harmonization. Historically I've found GitHub actually helps with this, having PIs all weigh in and engage with each other in a single shared space that is documented forever. They tend to find it an engaging forum. 